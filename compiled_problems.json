{
    "1980A": {
        "name": "A. Problem Generator",
        "time_limit": {
            "value": 1,
            "unit": "second"
        },
        "mem_limit": {
            "value": 256,
            "unit": "megabytes"
        },
        "description": "Vlad is planning to hold m rounds next month. Each round should contain one problem of difficulty levels 'A', 'B', 'C', 'D', 'E', 'F', and 'G'.Vlad already has a bank of n problems, where the i-th problem has a difficulty level of a_i. There may not be enough of these problems, so he may have to come up with a few more problems.Vlad wants to come up with as few problems as possible, so he asks you to find the minimum number of problems he needs to come up with in order to hold m rounds.For example, if m=1, n = 10, a= 'BGECDCBDED', then he needs to come up with two problems: one of difficulty level 'A' and one of difficulty level 'F'.",
        "inputSpecification": "The first line contains a single integer t (1 \\le t \\le 1000) the number of test cases.The first line of each test case contains two integers n and m (1 \\le n \\le 50, 1 \\le m \\le 5) the number of problems in the bank and the number of upcoming rounds, respectively.The second line of each test case contains a string a of n characters from 'A' to 'G' the difficulties of the problems in the bank.",
        "outputSpecification": "For each test case, output a single integer the minimum number of problems that need to come up with to hold m rounds.",
        "public_tests": [
            {
                "input": "\n310 1BGECDCBDED10 2BGECDCBDED9 1BBCDEFFGG",
                "output": "\n2\n5\n1\n"
            }
        ],
        "note": null,
        "tags": [
            "math",
            "*800"
        ]
    },
    "1980B": {
        "name": "B. Choosing Cubes",
        "time_limit": {
            "value": 1,
            "unit": "second"
        },
        "mem_limit": {
            "value": 256,
            "unit": "megabytes"
        },
        "description": "Dmitry has n cubes, numbered from left to right from 1 to n. The cube with index f is his favorite.Dmitry threw all the cubes on the table, and the i-th cube showed the value a_i (1 \\le a_i \\le 100). After that, he arranged the cubes in non-increasing order of their values, from largest to smallest. If two cubes show the same value, they can go in any order.After sorting, Dmitry removed the first k cubes. Then he became interested in whether he removed his favorite cube (note that its position could have changed after sorting).For example, if n=5, f=2, a = [4, \\color{green}3, 3, 2, 3] (the favorite cube is highlighted in green), and k = 2, the following could have happened:  After sorting a=[4, \\color{green}3, 3, 3, 2], since the favorite cube ended up in the second position, it will be removed.  After sorting a=[4, 3, \\color{green}3, 3, 2], since the favorite cube ended up in the third position, it will not be removed. ",
        "inputSpecification": "The first line contains an integer t (1 \\le t \\le 1000)  the number of test cases. Then follow the descriptions of the test cases.The first line of each test case description contains three integers n, f, and k (1 \\le f, k \\le n \\le 100)  the number of cubes, the index of Dmitry's favorite cube, and the number of removed cubes, respectively.The second line of each test case description contains n integers a_i (1 \\le a_i \\le 100)  the values shown on the cubes.",
        "outputSpecification": "For each test case, output one line  \"YES\" if the cube will be removed in all cases, \"NO\" if it will not be removed in any case, \"MAYBE\" if it may be either removed or left.You can output the answer in any case. For example, the strings \"YES\", \"nO\", \"mAyBe\" will be accepted as answers.",
        "public_tests": [
            {
                "input": "\n125 2 24 3 3 2 35 5 34 2 1 3 55 5 25 2 4 1 35 5 51 2 5 4 35 5 43 1 2 4 55 5 54 3 2 1 56 5 31 2 3 1 2 310 1 11 1 1 1 1 1 1 1 1 11 1 1425 2 32 2 1 1 22 1 12 15 3 13 3 2 3 2",
                "output": "\nMAYBE\nYES\nNO\nYES\nYES\nYES\nMAYBE\nMAYBE\nYES\nYES\nYES\nNO\n"
            }
        ],
        "note": null,
        "tags": [
            "sortings",
            "sortings",
            "*800"
        ]
    },
    "1980C": {
        "name": "C. Sofia and the Lost Operations",
        "time_limit": {
            "value": 2,
            "unit": "seconds"
        },
        "mem_limit": {
            "value": 256,
            "unit": "megabytes"
        },
        "description": "Sofia had an array of n integers a_1, a_2, \\ldots, a_n. One day she got bored with it, so she decided to sequentially apply m modification operations to it.Each modification operation is described by a pair of numbers \\langle c_j, d_j \\rangle and means that the element of the array with index c_j should be assigned the value d_j, i.e., perform the assignment a_{c_j} = d_j. After applying all modification operations sequentially, Sofia discarded the resulting array.Recently, you found an array of n integers b_1, b_2, \\ldots, b_n. You are interested in whether this array is Sofia's array. You know the values of the original array, as well as the values d_1, d_2, \\ldots, d_m. The values c_1, c_2, \\ldots, c_m turned out to be lost.Is there a sequence c_1, c_2, \\ldots, c_m such that the sequential application of modification operations \\langle c_1, d_1, \\rangle, \\langle c_2, d_2, \\rangle, \\ldots, \\langle c_m, d_m \\rangle to the array a_1, a_2, \\ldots, a_n transforms it into the array b_1, b_2, \\ldots, b_n?",
        "inputSpecification": "The first line contains an integer t (1 \\le t \\le 10^4) the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer n (1 \\le n \\le 2 \\cdot 10^5) the size of the array.The second line of each test case contains n integers a_1, a_2, \\ldots, a_n (1 \\le a_i \\le 10^9) the elements of the original array.The third line of each test case contains n integers b_1, b_2, \\ldots, b_n (1 \\le b_i \\le 10^9) the elements of the found array.The fourth line contains an integer m (1 \\le m \\le 2 \\cdot 10^5) the number of modification operations.The fifth line contains m integers d_1, d_2, \\ldots, d_m (1 \\le d_j \\le 10^9) the preserved value for each modification operation.It is guaranteed that the sum of the values of n for all test cases does not exceed 2 \\cdot 10^5, similarly the sum of the values of m for all test cases does not exceed 2 \\cdot 10^5.",
        "outputSpecification": "Output t lines, each of which is the answer to the corresponding test case. As an answer, output \"YES\" if there exists a suitable sequence c_1, c_2, \\ldots, c_m, and \"NO\" otherwise.You can output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\" and \"YES\" will be recognized as a positive answer).",
        "public_tests": [
            {
                "input": "\n731 2 11 3 241 3 1 241 2 3 52 1 3 522 357 6 1 10 103 6 1 11 1134 3 1143 1 7 82 2 7 10510 3 2 2 155 7 1 7 94 10 1 2 981 1 9 8 7 2 10 441000000000 203 203 203203 1000000000 203 10000000002203 100000000011151 3 4 5 1",
                "output": "\nYES\nNO\nNO\nNO\nYES\nNO\nYES\n"
            }
        ],
        "note": null,
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1300"
        ]
    },
    "1980D": {
        "name": "D. GCD-sequence",
        "time_limit": {
            "value": 2,
            "unit": "seconds"
        },
        "mem_limit": {
            "value": 256,
            "unit": "megabytes"
        },
        "description": "GCD (Greatest Common Divisor) of two integers x and y is the maximum integer z by which both x and y are divisible. For example, GCD(36, 48) = 12, GCD(5, 10) = 5, and GCD(7,11) = 1.Kristina has an array a consisting of exactly n positive integers. She wants to count the GCD of each neighbouring pair of numbers to get a new array b, called GCD-sequence. So, the elements of the GCD-sequence b will be calculated using the formula b_i = GCD(a_i, a_{i + 1}) for 1 \\le i \\le n - 1.Determine whether it is possible to remove exactly one number from the array a so that the GCD sequence b is non-decreasing (i.e., b_i \\le b_{i+1} is always true).For example, let Khristina had an array a = [20, 6, 12, 3, 48, 36]. If she removes a_4 = 3 from it and counts the GCD-sequence of b, she gets:  b_1 = GCD(20, 6) = 2  b_2 = GCD(6, 12) = 6  b_3 = GCD(12, 48) = 12  b_4 = GCD(48, 36) = 12  The resulting GCD sequence b = [2,6,12,12] is non-decreasing because b_1 \\le b_2 \\le b_3 \\le b_4.",
        "inputSpecification": "The first line of input data contains a single number t (1 \\le t \\le 10^4) he number of test cases in the test.This is followed by the descriptions of the test cases.The first line of each test case contains a single integer n (3 \\le n \\le 2 \\cdot 10^5)  the number of elements in the array a.The second line of each test case contains exactly n integers a_i (1 \\le a_i \\le 10^9)  the elements of array a.It is guaranteed that the sum of n over all test case does not exceed 2 \\cdot 10^5.",
        "outputSpecification": "For each test case, output a single line:   \"YES\" if you can remove exactly one number from the array a so that the GCD-sequence of b is non-decreasing;  \"NO\" otherwise. You can output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will all be recognized as a positive answer).",
        "public_tests": [
            {
                "input": "\n12620 6 12 3 48 36412 6 3 4310 12 3532 16 8 4 25100 50 2 10 2042 4 8 1107 4 6 2 4 5 1 4 2 875 9 6 8 5 9 2611 14 8 12 9 395 7 3 10 6 3 12 6 334 2 481 6 11 12 6 12 3 6",
                "output": "\nYES\nNO\nYES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\n"
            }
        ],
        "note": "The first test case is explained in the problem statement.",
        "tags": [
            "greedy",
            "implementation",
            "math",
            "number theory",
            "*1400"
        ]
    },
    "1980E": {
        "name": "E. Permutation of Rows and Columns",
        "time_limit": {
            "value": 3,
            "unit": "seconds"
        },
        "mem_limit": {
            "value": 256,
            "unit": "megabytes"
        },
        "description": "You have been given a matrix a of size n by m, containing a permutation of integers from 1 to n \\cdot m.A permutation of n integers is an array containing all numbers from 1 to n exactly once. For example, the arrays [1], [2, 1, 3], [5, 4, 3, 2, 1] are permutations, while the arrays [1, 1], [100], [1, 2, 4, 5] are not.A matrix contains a permutation if, when all its elements are written out, the resulting array is a permutation. Matrices [[1, 2], [3, 4]], [[1]], [[1, 5, 3], [2, 6, 4]] contain permutations, while matrices [[2]], [[1, 1], [2, 2]], [[1, 2], [100, 200]] do not.You can perform one of the following two actions in one operation:  choose columns c and d (1 \\le c, d \\le m, c \\ne d) and swap these columns;  choose rows c and d (1 \\le c, d \\le n, c \\ne d) and swap these rows. You can perform any number of operations.You are given the original matrix a and the matrix b. Your task is to determine whether it is possible to transform matrix a into matrix b using the given operations.",
        "inputSpecification": "The first line contains an integer t (1 \\le t \\le 10^4)  the number of test cases. The descriptions of the test cases follow.The first line of each test case description contains 2 integers n and m (1 \\le n, m \\le n \\cdot m \\le 2 \\cdot 10^5)  the sizes of the matrix.The next n lines contain m integers a_{ij} each (1 \\le a_{ij} \\le n \\cdot m). It is guaranteed that matrix a is a permutation.The next n lines contain m integers b_{ij} each (1 \\le b_{ij} \\le n \\cdot m). It is guaranteed that matrix b is a permutation.It is guaranteed that the sum of the values n \\cdot m for all test cases does not exceed 2 \\cdot 10^5.",
        "outputSpecification": "For each test case, output \"YES\" if the second matrix can be obtained from the first, and \"NO\" otherwise.You can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive answer.",
        "public_tests": [
            {
                "input": "\n71 1112 21 23 44 32 12 21 23 44 31 23 41 5 9 612 10 4 87 11 3 21 5 9 612 10 4 87 11 3 23 31 5 96 4 23 8 79 5 12 4 67 8 32 31 2 65 4 36 1 23 4 51 55 1 2 3 44 2 5 1 3",
                "output": "\nYES\nYES\nNO\nYES\nYES\nNO\nYES\n"
            }
        ],
        "note": "In the second example, the original matrix looks like this: \\begin{pmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\end{pmatrix} By swapping rows 1 and 2, it becomes: \\begin{pmatrix} 3 &amp; 4 \\\\ 1 &amp; 2 \\end{pmatrix} By swapping columns 1 and 2, it becomes equal to matrix b: \\begin{pmatrix} 4 &amp; 3 \\\\ 2 &amp; 1 \\end{pmatrix} ",
        "tags": [
            "constructive algorithms",
            "data structures",
            "greedy",
            "hashing",
            "implementation",
            "math",
            "matrices",
            "sortings",
            "*1600"
        ]
    },
    "1981A": {
        "name": "A. Turtle and Piggy Are Playing a Game",
        "time_limit": {
            "value": 1,
            "unit": "second"
        },
        "mem_limit": {
            "value": 256,
            "unit": "megabytes"
        },
        "description": "Turtle and Piggy are playing a number game.First, Turtle will choose an integer x, such that l \\le x \\le r, where l, r are given. It's also guaranteed that 2l \\le r.Then, Piggy will keep doing the following operation until x becomes 1:  Choose an integer p such that p \\ge 2 and p \\mid x (i.e. x is a multiple of p).  Set x to \\frac{x}{p}, and the score will increase by 1. The score is initially 0. Both Turtle and Piggy want to maximize the score. Please help them to calculate the maximum score.",
        "inputSpecification": "Each test contains multiple test cases. The first line contains the number of test cases t (1 \\le t \\le 10^4). The description of the test cases follows.The first line of each test case contains two integers l, r (1 \\le l \\le r \\le 10^9, 2l \\le r)  The range where Turtle can choose the integer from.",
        "outputSpecification": "For each test case, output a single integer  the maximum score.",
        "public_tests": [
            {
                "input": "\n52 43 62 156 22114514 1919810",
                "output": "\n2\n2\n3\n4\n20\n"
            }
        ],
        "note": "In the first test case, Turtle can choose an integer x, such that 2 \\le x \\le 4. He can choose x = 4. Then Piggy can choose p = 2 for 2 times. After that, x will become 1, and the score will be 2, which is maximized.In the second test case, Turtle can choose an integer 3 \\le x \\le 6. He can choose x = 6. Then Piggy can choose p = 2, then choose p = 3. After that, x will become 1, and the score will be 2, which is maximum.In the third test case, Turtle can choose x = 12.In the fourth test case, Turtle can choose x = 16.",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "*800"
        ]
    },
    "1981B": {
        "name": "B. Turtle and an Infinite Sequence",
        "time_limit": {
            "value": 1,
            "unit": "second"
        },
        "mem_limit": {
            "value": 256,
            "unit": "megabytes"
        },
        "description": "There is a sequence a_0, a_1, a_2, \\ldots of infinite length. Initially a_i = i for every non-negative integer i.After every second, each element of the sequence will simultaneously change. a_i will change to a_{i - 1} \\mid a_i \\mid a_{i + 1} for every positive integer i. a_0 will change to a_0 \\mid a_1. Here, | denotes bitwise OR.Turtle is asked to find the value of a_n after m seconds. In particular, if m = 0, then he needs to find the initial value of a_n. He is tired of calculating so many values, so please help him!",
        "inputSpecification": "Each test contains multiple test cases. The first line contains the number of test cases t (1 \\le t \\le 10^4). The description of the test cases follows.The first line of each test case contains two integers n, m (0 \\le n, m \\le 10^9).",
        "outputSpecification": "For each test case, output a single integer  the value of a_n after m seconds.",
        "public_tests": [
            {
                "input": "\n90 00 10 21 05 210 120 31145 1419198 10",
                "output": "\n0\n1\n3\n1\n7\n11\n23\n1279\n19455\n"
            }
        ],
        "note": "After 1 second, [a_0, a_1, a_2, a_3, a_4, a_5] will become [1, 3, 3, 7, 7, 7].After 2 seconds, [a_0, a_1, a_2, a_3, a_4, a_5] will become [3, 3, 7, 7, 7, 7].",
        "tags": [
            "bitmasks",
            "math",
            "*1300"
        ]
    },
    "1981C": {
        "name": "C. Turtle and an Incomplete Sequence",
        "time_limit": {
            "value": 3,
            "unit": "seconds"
        },
        "mem_limit": {
            "value": 256,
            "unit": "megabytes"
        },
        "description": "Turtle was playing with a sequence a_1, a_2, \\ldots, a_n consisting of positive integers. Unfortunately, some of the integers went missing while playing.Now the sequence becomes incomplete. There may exist an arbitrary number of indices i such that a_i becomes -1. Let the new sequence be a'.Turtle is sad. But Turtle remembers that for every integer i from 1 to n - 1, either a_i = \\left\\lfloor\\frac{a_{i + 1}}{2}\\right\\rfloor or a_{i + 1} = \\left\\lfloor\\frac{a_i}{2}\\right\\rfloor holds for the original sequence a.Turtle wants you to help him complete the sequence. But sometimes Turtle makes mistakes, so you need to tell him if you can't complete the sequence.Formally, you need to find another sequence b_1, b_2, \\ldots, b_n consisting of positive integers such that:  For every integer i from 1 to n, if a'_i \\ne -1, then b_i = a'_i.  For every integer i from 1 to n - 1, either b_i = \\left\\lfloor\\frac{b_{i + 1}}{2}\\right\\rfloor or b_{i + 1} = \\left\\lfloor\\frac{b_i}{2}\\right\\rfloor holds.  For every integer i from 1 to n, 1 \\le b_i \\le 10^9. If there is no sequence b_1, b_2, \\ldots, b_n that satisfies all of the conditions above, you need to report -1.",
        "inputSpecification": "Each test contains multiple test cases. The first line contains the number of test cases t (1 \\le t \\le 10^5). The description of the test cases follows.The first line of each test case contains a single integer n (2 \\le n \\le 2 \\cdot 10^5)  the length of the sequence.The second line of each test case contains n integers a'_1, a'_2, \\ldots, a'_n (a'_i = -1 or 1 \\le a'_i \\le 10^8)  the elements of the sequence a'.It is guaranteed that the sum of n over all test cases does not exceed 2 \\cdot 10^5.",
        "outputSpecification": "For each test case, if there is no sequence b_1, b_2, \\ldots, b_n that satisfies all of the conditions, output a single integer -1.Otherwise, output n integers b_1, b_2, \\ldots, b_n  the elements of the sequence b_1, b_2, \\ldots, b_n you find. The sequence should satisfy that 1 \\le b_i \\le 10^9 for every integer i from 1 to n. If there are multiple answers, print any of them.",
        "public_tests": [
            {
                "input": "\n98-1 -1 -1 2 -1 -1 1 -14-1 -1 -1 -163 -1 -1 -1 9 -14-1 5 -1 642 -1 -1 341 2 3 424 25-1 3 -1 3 613-1 -1 3 -1 -1 -1 -1 7 -1 -1 3 -1 -1",
                "output": "\n4 9 4 2 4 2 1 2\n7 3 6 13\n3 1 2 4 9 18\n-1\n-1\n-1\n4 2\n6 3 1 3 6\n3 1 3 1 3 7 3 7 3 1 3 1 3\n"
            }
        ],
        "note": "In the first test case, [4, 2, 1, 2, 1, 2, 1, 3] can also be the answer, while [4, 2, 5, 10, 5, 2, 1, 3] and [4, 2, 1, 2, 1, 2, 1, 4] cannot.In the second test case, [1, 2, 5, 2] can also be the answer.From the fourth to the sixth test cases, it can be shown that there is no answer, so you should output -1.",
        "tags": [
            "bitmasks",
            "brute force",
            "constructive algorithms",
            "greedy",
            "implementation",
            "math",
            "*1800"
        ]
    },
    "1981D": {
        "name": "D. Turtle and Multiplication",
        "time_limit": {
            "value": 3,
            "unit": "seconds"
        },
        "mem_limit": {
            "value": 512,
            "unit": "megabytes"
        },
        "description": "Turtle just learned how to multiply two integers in his math class, and he was very excited.Then Piggy gave him an integer n, and asked him to construct a sequence a_1, a_2, \\ldots, a_n consisting of integers which satisfied the following conditions:  For all 1 \\le i \\le n, 1 \\le a_i \\le 3 \\cdot 10^5.  For all 1 \\le i &lt; j \\le n - 1, a_i \\cdot a_{i + 1} \\ne a_j \\cdot a_{j + 1}. Of all such sequences, Piggy asked Turtle to find the one with the minimum number of distinct elements.Turtle definitely could not solve the problem, so please help him!",
        "inputSpecification": "Each test contains multiple test cases. The first line contains the number of test cases t (1 \\le t \\le 10^4). The description of the test cases follows.The first line of each test case contains a single integer n (2 \\le n \\le 10^6)  the length of the sequence a.It is guaranteed that the sum of n over all test cases does not exceed 10^6.",
        "outputSpecification": "For each test case, output n integers a_1, a_2, \\ldots, a_n  the elements of the sequence a.If there are multiple answers, print any of them.",
        "public_tests": [
            {
                "input": "\n3234",
                "output": "\n114514 114514\n1 2 2\n3 3 4 4\n"
            }
        ],
        "note": "In the third test case, a = [3, 4, 2, 6] violates the second condition since a_1 \\cdot a_2 = a_3 \\cdot a_4. a = [2, 3, 4, 4] satisfy the conditions but its number of distinct elements isn't minimum.",
        "tags": [
            "constructive algorithms",
            "dfs and similar",
            "graphs",
            "number theory",
            "*2400"
        ]
    },
    "1981E": {
        "name": "E. Turtle and Intersected Segments",
        "time_limit": {
            "value": 5,
            "unit": "seconds"
        },
        "mem_limit": {
            "value": 512,
            "unit": "megabytes"
        },
        "description": "Turtle just received n segments and a sequence a_1, a_2, \\ldots, a_n. The i-th segment is [l_i, r_i].Turtle will create an undirected graph G. If segment i and segment j intersect, then Turtle will add an undirected edge between i and j with a weight of |a_i - a_j|, for every i \\ne j.Turtle wants you to calculate the sum of the weights of the edges of the minimum spanning tree of the graph G, or report that the graph G has no spanning tree.We say two segments [l_1, r_1] and [l_2, r_2] intersect if and only if \\max(l_1, l_2) \\le \\min(r_1, r_2).",
        "inputSpecification": "Each test contains multiple test cases. The first line contains the number of test cases t (1 \\le t \\le 10^5). The description of the test cases follows.The first line of each test case contains a single integer n (2 \\le n \\le 5 \\cdot 10^5)  the number of segments.The i-th of the following n lines contains three integers l_i, r_i, a_i (1 \\le l_i \\le r_i \\le 10^9, 1 \\le a_i \\le 10^9)  the i-th segment and the i-th element of the sequence.It is guaranteed that the sum of n over all test cases does not exceed 5 \\cdot 10^5.",
        "outputSpecification": "For each test case, output a single integer  the sum of the weights of the edges of the minimum spanning tree of the graph G. If the graph G has no spanning tree, output -1.",
        "public_tests": [
            {
                "input": "\n451 7 32 4 63 5 56 7 93 4 452 7 31 3 64 5 56 7 91 1 441 4 31 2 13 4 51 4 431 3 12 3 34 5 8",
                "output": "\n9\n13\n4\n-1\n"
            }
        ],
        "note": "In the first test case, the graph G is as follows:  One of the minimum spanning trees of G is as follows:  The sum of the weights of the edges of the minimum spanning tree is 9.In the second test case, the graph G is as follows:  G is already a tree, and the sum of the weights of the tree is 13.In the third test case, the graph G is as follows:  In the fourth test case, the graph G is as follows:  It's easy to see that G is not connected, so G has no spanning tree.",
        "tags": [
            "data structures",
            "dsu",
            "graphs",
            "greedy",
            "*2600"
        ]
    },
    "1981F": {
        "name": "F. Turtle and Paths on a Tree",
        "time_limit": {
            "value": 4,
            "unit": "seconds"
        },
        "mem_limit": {
            "value": 1024,
            "unit": "megabytes"
        },
        "description": "Note the unusual definition of \\text{MEX} in this problem.Piggy gave Turtle a binary tree^{\\dagger} with n vertices and a sequence a_1, a_2, \\ldots, a_n on his birthday. The binary tree is rooted at vertex 1.If a set of paths P = \\{(x_i, y_i)\\} in the tree covers each edge exactly once, then Turtle will think that the set of paths is good. Note that a good set of paths can cover a vertex twice or more.Turtle defines the value of a set of paths as \\sum\\limits_{(x, y) \\in P} f(x, y), where f(x, y) denotes the \\text{MEX}^{\\ddagger} of all a_u such that vertex u is on the simple path from x to y in the tree (including the starting vertex x and the ending vertex y).Turtle wonders the minimum value over all good sets of paths. Please help him calculate the answer!^{\\dagger}A binary tree is a tree where every non-leaf vertex has at most 2 sons.^{\\ddagger}\\text{MEX} of a collection of integers c_1, c_2, \\ldots, c_k is defined as the smallest positive integer x which does not occur in the collection c. For example, \\text{MEX} of [3, 3, 1, 4] is 2, \\text{MEX} of [2, 3] is 1.",
        "inputSpecification": "Each test contains multiple test cases. The first line contains the number of test cases t (1 \\le t \\le 10^4). The description of the test cases follows.The first line of each test case contains a single integer n (2 \\le n \\le 2.5 \\cdot 10^4)  the number of vertices in the tree.The second line of each test case contains n integers a_1, a_2, \\ldots, a_n (1 \\le a_i \\le 10^9)  the elements of the sequence a.The third line of each test case contains n - 1 integers p_2, p_3, \\ldots, p_n (1 \\le p_i &lt; i)  the parent of each vertex in the tree.Additional constraint on the input: the given tree is a binary tree, that is, every non-leaf vertex has at most 2 sons.It is guaranteed that the sum of n over all test cases does not exceed 10^5.",
        "outputSpecification": "For each test case, output a single integer  the minimum value over all good sets of paths.",
        "public_tests": [
            {
                "input": "\n553 2 2 1 11 1 2 253 2 1 1 11 1 2 261 2 1 2 1 31 2 3 3 472 1 2 3 1 2 11 1 2 2 3 3101 2 2 1 4 2 3 1 2 11 1 2 2 3 3 4 5 5",
                "output": "\n4\n6\n6\n6\n7\n"
            }
        ],
        "note": "In the first test case, the tree is as follows. The number in brackets denotes the weight of the vertex:  The good set of paths with the minimum value is \\{(2, 3), (4, 5)\\}.Note that in this test case \\{(4, 5)\\} and \\{(3, 4), (4, 5)\\} are not good sets of paths because each edge should be covered exactly once.In the second test case, the tree is as follows:  The set of good paths with the minimum value is \\{(1, 2), (1, 3), (4, 5)\\}.In the third test case, the tree is as follows:  The set of good paths with the minimum value is \\{(1, 6), (3, 5)\\}.",
        "tags": [
            "data structures",
            "dp",
            "trees",
            "*3000"
        ]
    },
    "1982A": {
        "name": "A. Soccer",
        "time_limit": {
            "value": 1,
            "unit": "second"
        },
        "mem_limit": {
            "value": 256,
            "unit": "megabytes"
        },
        "description": "Dima loves watching soccer. In such a game, the score on the scoreboard is represented as x : y, where x is the number of goals of the first team, and y is the number of goals of the second team. At any given time, only one team can score a goal, so the score x : y can change to either (x + 1) : y, or x : (y + 1).While watching a soccer game, Dima was distracted by very important matters, and after some time, he returned to watching the game. Dima remembers the score right before he was distracted, and the score right after he returned. Given these two scores, he wonders the following question. Is it possible that, while Dima was not watching the game, the teams never had an equal score?It is guaranteed that at neither of the two time points Dima remembers the teams had equal scores. However, it is possible that the score did not change during his absence.Help Dima and answer the question!",
        "inputSpecification": "Each test consists of several test cases. The first line contains an integer t (1 \\le t \\le 10^{4}) the number of test cases. Then follows the description of the test cases.The first line of each test case contains two integers x_{1}, y_{1} (0 \\le x_{1}, y_{1} \\le 10^{9}, x_{1} \\neq y_{1}) the score before Dima was distracted.The second line of each test case contains two integers x_{2}, y_{2} (x_{1} \\le x_{2} \\le 10^{9}, y_{1} \\le y_{2} \\le 10^{9}, x_{2} \\neq y_{2}) the score when Dima returned.",
        "outputSpecification": "For each test case, output \"YES\" without quotes if it is possible, that the teams never had a tie while Dima was away, otherwise output \"NO\" without quotes.You can output each letter in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).",
        "public_tests": [
            {
                "input": "\n61 05 01 23 21 24 51 24 31 21 2998244353 01000000000 999999999",
                "output": "\nYES\nNO\nYES\nNO\nYES\nYES\n"
            }
        ],
        "note": "In the first test case, the score before Dima left was 1 : 0. When he leaves, the first team scores several goals in a row until the score becomes 5 : 0, so the answer is YES.In the second test case, the score could only change as follows:  1 : 2  2 : 2  3 : 2 In this scenario, there is a moment when the teams have an equal score, so the answer is NO.In the third test case, one of the possible developments is:  1 : 2  1 : 3  2 : 3  2 : 4  2 : 5  3 : 5  4 : 5 In this scenario, there was no time when the score was equal, so the answer is YES.",
        "tags": [
            "greedy",
            "implementation",
            "math",
            "sortings",
            "*800"
        ]
    },
    "1982B": {
        "name": "B. Collatz Conjecture",
        "time_limit": {
            "value": 1,
            "unit": "second"
        },
        "mem_limit": {
            "value": 256,
            "unit": "megabytes"
        },
        "description": "Recently, the first-year student Maxim learned about the Collatz conjecture, but he didn't pay much attention during the lecture, so he believes that the following process is mentioned in the conjecture:There is a variable x and a constant y. The following operation is performed k times:   increase x by 1, then  while the number x is divisible by y, divide it by y.  Note that both of these actions are performed sequentially within one operation.For example, if the number x = 16, y = 3, and k = 2, then after one operation x becomes 17, and after another operation x becomes 2, because after adding one, x = 18 is divisible by 3 twice.Given the initial values of x, y, and k, Maxim wants to know what is the final value of x.",
        "inputSpecification": "Each test consists of multiple test cases. The first line contains an integer t (1 \\le t \\le 10^{4}) the number of test cases. Then follows the description of the test cases.The only line of each test case contains three integers x, y, and k (1 \\le x, k \\le 10^{9}, 2 \\le y \\le 10^{9}) the initial variable, constant and the number of operations.",
        "outputSpecification": "For each test case, output a single integer the number obtained after applying k operations.",
        "public_tests": [
            {
                "input": "\n131 3 12 3 124 5 516 3 22 2 11337 18 11 2 14413312345678 3 10998244353 2 998244353998244353 123456789 998244352998244354 998241111 998244352998244355 2 99824431000000000 1000000000 1000000000",
                "output": "\n2\n1\n1\n2\n3\n1338\n1\n16936\n1\n21180097\n6486\n1\n2\n"
            }
        ],
        "note": "In the first test case, there is only one operation applied to x = 1, resulting in x becoming 2.In the second test case, for x = 2, within one operation, one is added to x and it's divided by y = 3, resulting in x becoming 1.In the third test case, x changes as follows:  After the first operation, x = 1, because 24 + 1 = 25 and 25 is divisible by y = 5 twice within one operation.  After the second operation, x = 2.  After the third operation, x = 3.  After the fourth operation, x = 4.  After the fifth operation, x = 1. ",
        "tags": [
            "brute force",
            "implementation",
            "math",
            "number theory",
            "*1200"
        ]
    },
    "1982C": {
        "name": "C. Boring Day",
        "time_limit": {
            "value": 2,
            "unit": "seconds"
        },
        "mem_limit": {
            "value": 256,
            "unit": "megabytes"
        },
        "description": "On another boring day, Egor got bored and decided to do something. But since he has no friends, he came up with a game to play.Egor has a deck of n cards, the i-th card from the top has a number a_i written on it. Egor wants to play a certain number of rounds until the cards run out. In each round, he takes a non-zero number of cards from the top of the deck and finishes the round. If the sum of the numbers on the cards collected during the round is between l and r, inclusive, the round is won; otherwise, it is lost. Egor knows by heart the order of the cards. Help Egor determine the maximum number of rounds he can win in such a game. Note that Egor is not required to win rounds consecutively.",
        "inputSpecification": "Each test consists of several test cases. The first line contains an integer t (1 \\le t \\le 10^{4}) the number of test cases. This is followed by a description of the test cases.The first line of each test case contains three integers n, l, and r (1 \\le n \\le 10^{5}, 1 \\le l \\le r \\le 10^9).The second line of each test case contains n integers a_1, a_2, \\ldots, a_n (1 \\le a_i \\le 10^9) the numbers on the cards from top to bottom.It is guaranteed that the sum of n for all test cases does not exceed 2 \\cdot 10^{5}.",
        "outputSpecification": "For each test case, output a single number the maximum number of rounds Egor can win.",
        "public_tests": [
            {
                "input": "\n85 3 102 1 11 3 710 1 517 8 12 11 7 11 21 13 10 83 4 53 4 28 12 2510 7 5 13 8 9 12 72 3 35 29 7 92 10 5 1 3 7 6 2 31 8 1095 5 61 4 2 6 4",
                "output": "\n3\n0\n1\n4\n0\n3\n1\n2\n"
            }
        ],
        "note": "In the first test case, Egor can win 3 rounds:  In the first round, take the top 2 cards with values 2 and 1 and win, as their sum is 3. After this, the deck will look like this: [11, 3, 7].  In the second round, take the top card and lose, as its value 11 is greater than r = 10. After this, the deck will look like this: [3, 7].  In the third round, take the top card with value 3 and win. After this, the deck will look like this: [7].  After this, in the fourth round, Egor only has to take the last card in the deck with value 7 and win again. In the second test case, Egor cannot win any rounds, no matter how hard he tries.In the third test case, you can take one card in each round, then the first and third rounds will be losing, and the second round will be winning.In the fourth test case, you can take two cards in each round and always win.",
        "tags": [
            "binary search",
            "data structures",
            "dp",
            "greedy",
            "two pointers",
            "*1200"
        ]
    },
    "1982D": {
        "name": "D. Beauty of the mountains",
        "time_limit": {
            "value": 2,
            "unit": "seconds"
        },
        "mem_limit": {
            "value": 256,
            "unit": "megabytes"
        },
        "description": "Nikita loves mountains and has finally decided to visit the Berlyand mountain range! The range was so beautiful that Nikita decided to capture it on a map. The map is a table of n rows and m columns, with each cell containing a non-negative integer representing the height of the mountain.He also noticed that mountains come in two types:  With snowy caps.  Without snowy caps. Nikita is a very pragmatic person. He wants the sum of the heights of the mountains with snowy caps to be equal to the sum of the heights of the mountains without them. He has arranged with the mayor of Berlyand, Polikarp Polikarpovich, to allow him to transform the landscape.Nikita can perform transformations on submatrices of size k \\times k as follows: he can add an integer constant c to the heights of the mountains within this area, but the type of the mountain remains unchanged. Nikita can choose the constant c independently for each transformation. Note that c can be negative.Before making the transformations, Nikita asks you to find out if it is possible to achieve equality of the sums, or if it is impossible. It doesn't matter at what cost, even if the mountains turn into canyons and have negative heights.If only one type of mountain is represented on the map, then the sum of the heights of the other type of mountain is considered to be zero.",
        "inputSpecification": "Each test consists of several test cases. The first line contains an integer t (1 \\le t \\le 10^{4}) the number of test cases. This is followed by a description of test cases.The first line of each test case contains three integers n, m, k (1 \\le n, m \\le 500, 1 \\le k \\le min(n, m)).The next n lines of each test case contain m integers a_{i j} (0 \\le a_{i j} \\le 10^{9}) the initial heights of the mountains.The next n binary strings of length m for each test case determine the type of mountain, '0' with snowy caps, '1' without them.It is guaranteed that the sum of n \\cdot m for all test cases does not exceed 250\\,000.",
        "outputSpecification": "For each test case, output \"YES\" without quotes if it is possible to equalize the sums of the mountain heights, otherwise output \"NO\" without quotes. You can output each letter in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).",
        "public_tests": [
            {
                "input": "\n83 3 27 11 34 2 30 1 151000100004 4 3123 413 24 233123 42 0 21622 1 1 53427 763 22 601011111101001013 3 22 1 11 1 21 5 40101010103 3 22 1 11 1 21 5 30101010103 4 346 49 50 119 30 23 1230 25 1 461000010000105 4 439 30 0 1722 42 30 1310 44 46 3512 19 9 3921 0 45 40100011110011011111002 2 23 46 700002 2 20 02 00100",
                "output": "\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nYES\n"
            }
        ],
        "note": "The mountain array from the first test case looks like this:  Initially, the sum of the heights of the mountains with snowy caps is 11 + 3 + 4 + 3 + 0 + 1 + 15 = 37, and without them is 7 + 2 = 9.To equalize these sums, we can perform two transformations:First transformation:  Note that the constant c can be negative.After the first transformation, the mountain array looks like this:  Second transformation:  As a result, the mountain array looks like this:  The sum of the heights of the mountains with snowy caps is 17 + 9 + 9 - 16 - 20 - 19 + 15 = -5, and without them is 7 - 12 = -5, thus the answer is YES.",
        "tags": [
            "brute force",
            "data structures",
            "implementation",
            "math",
            "number theory",
            "*1700"
        ]
    },
    "1982E": {
        "name": "E. Number of k-good subarrays",
        "time_limit": {
            "value": 2,
            "unit": "seconds"
        },
        "mem_limit": {
            "value": 256,
            "unit": "megabytes"
        },
        "description": "Let bit(x) denote the number of ones in the binary representation of a non-negative integer x.A subarray of an array is called k-good if it consists only of numbers with no more than k ones in their binary representation, i.e., a subarray (l, r) of array a is good if for any i such that l \\le i \\le r condition bit(a_{i}) \\le k is satisfied.You are given an array a of length n, consisting of consecutive non-negative integers starting from 0, i.e., a_{i} = i for 0 \\le i \\le n - 1 (in 0-based indexing). You need to count the number of k-good subarrays in this array.As the answer can be very large, output it modulo 10^{9} + 7.",
        "inputSpecification": "Each test consists of multiple test cases. The first line contains an integer t (1 \\le t \\le 10^{4}) the number of test cases. The following lines describe the test cases.The single line of each test case contains two integers n, k (1 \\le n \\le 10^{18}, 1 \\le k \\le 60).",
        "outputSpecification": "For each test case, output a single integer the number of k-good subarrays modulo 10^{9} + 7.",
        "public_tests": [
            {
                "input": "\n106 116 21 13 131 314 11337 5100000 20795569939321040850 56576460752303423268 59",
                "output": "\n7\n35\n1\n6\n155\n8\n7323\n49965\n741136395\n66679884\n"
            }
        ],
        "note": "For the first test case a = [0, 1, 2, 3, 4, 5], k = 1.To find the answer, let's write all the numbers in binary representation:a = [\\color{green}{000}, \\color{green}{001}, \\color{green}{010}, \\color{red}{011}, \\color{green}{100}, \\color{red}{101}]From this, it can be seen that the numbers 3 and 5 have 2 \\ge (k = 1) ones in their binary representation, so the answer should include all subarrays that do not contain either 3 or 5, which are the subarrays (in 0-based indexing): (0, 0), (0, 1), (0, 2), (1, 1), (1, 2), (2, 2), (4, 4).",
        "tags": [
            "bitmasks",
            "brute force",
            "combinatorics",
            "divide and conquer",
            "dp",
            "math",
            "meet-in-the-middle",
            "*2300"
        ]
    },
    "1984A": {
        "name": "A. Strange Splitting",
        "time_limit": {
            "value": 1,
            "unit": "second"
        },
        "mem_limit": {
            "value": 256,
            "unit": "megabytes"
        },
        "description": "Define the range of a non-empty array to be the maximum value minus the minimum value. For example, the range of [1,4,2] is 4-1=3.You are given an array a_1, a_2, \\ldots, a_n of length n \\geq 3. It is guaranteed a is sorted.You have to color each element of a red or blue so that:   the range of the red elements does not equal the range of the blue elements, and  there is at least one element of each color. If there does not exist any such coloring, you should report it. If there are multiple valid colorings, you can print any of them.",
        "inputSpecification": "The first line contains a single integer t (1 \\leq t \\leq 100) the number of test cases.The first line of each test case contains an integer n (3 \\leq n \\leq 50) the length of the array.The second line of each test case contains n integers a_1, a_2, \\ldots, a_n (1 \\leq a_i \\leq 10^9). It is guaranteed a_1 \\leq a_2 \\leq \\ldots \\leq a_{n - 1} \\leq a_{n}.",
        "outputSpecification": "For each test case, if it is impossible to color a to satisfy all the constraints, output \\texttt{NO}.Otherwise, first output \\texttt{YES}.Then, output a string s of length n. For 1 \\leq i \\leq n, if you color a_i red, s_i should be \\texttt{R}. For 1 \\leq i \\leq n, if you color a_i blue, s_i should be \\texttt{B}. ",
        "public_tests": [
            {
                "input": "\n741 1 2 251 2 3 4 533 3 341 2 2 231 2 231 1 231 9 84",
                "output": "\nYES\nRBRR\nYES\nBBRBB\nNO\nYES\nRBBR\nYES\nRRB\nYES\nBRR\nYES\nBRB"
            }
        ],
        "note": "In the first test case, given the array [1, 1, 2, 2], we can color the second element blue and the remaining elements red; then the range of the red elements [1, 2, 2] is 2-1=1, and the range of the blue elements [1] is 1-1=0.In the second test case, we can color the first, second, fourth and fifth elements [1, 2, 4, 5] blue and the remaining elements [3] red. The range of the red elements is 3 - 3 = 0 and the range of the blue elements is 5 - 1 = 4, which are different.In the third test case, it can be shown there is no way to color a = [3, 3, 3] to satisfy the constraints.",
        "tags": [
            "constructive algorithms",
            "*800"
        ]
    },
    "1984B": {
        "name": "B. Large Addition",
        "time_limit": {
            "value": 1,
            "unit": "second"
        },
        "mem_limit": {
            "value": 256,
            "unit": "megabytes"
        },
        "description": "A digit is large if it is between 5 and 9, inclusive. A positive integer is large if all of its digits are large.You are given an integer x. Can it be the sum of two large positive integers with the same number of digits?",
        "inputSpecification": "The first line contains a single integer t (1 \\leq t \\leq 10^4) the number of test cases.The only line of each test case contains a single integer x (10 \\leq x \\leq 10^{18}).",
        "outputSpecification": "For each test case, output \\texttt{YES} if x satisfies the condition, and \\texttt{NO} otherwise.You can output \\texttt{YES} and \\texttt{NO} in any case (for example, strings \\texttt{yES}, \\texttt{yes}, and \\texttt{Yes} will be recognized as a positive response).",
        "public_tests": [
            {
                "input": "\n11133720013939381434987654321234567891111111111111111142019841069119",
                "output": "\nYES\nNO\nYES\nYES\nNO\nYES\nNO\nYES\nYES\nNO\nNO\n"
            }
        ],
        "note": "In the first test case, we can have 658 + 679 = 1337.In the second test case, it can be shown that no numbers of equal length and only consisting of large digits can add to 200.In the third test case, we can have 696\\,969 + 696\\,969 = 1\\,393\\,938.In the fourth test case, we can have 777 + 657 = 1434.",
        "tags": [
            "implementation",
            "math",
            "*1100"
        ]
    },
    "1984D": {
        "name": "D. \"a\" String Problem",
        "time_limit": {
            "value": 2,
            "unit": "seconds"
        },
        "mem_limit": {
            "value": 256,
            "unit": "megabytes"
        },
        "description": "You are given a string s consisting of lowercase Latin characters. Count the number of nonempty strings t \\neq \"\\texttt{a}\" such that it is possible to partition^{\\dagger} s into some substrings satisfying the following conditions:   each substring either equals t or \"\\texttt{a}\", and  at least one substring equals t.  ^{\\dagger} A partition of a string s is an ordered sequence of some k strings t_1, t_2, \\ldots, t_k (called substrings) such that t_1 + t_2 + \\ldots + t_k = s, where + represents the concatenation operation.",
        "inputSpecification": "The first line contains a single integer t (1 \\leq t \\leq 10^4) the number of test cases.The only line of each test case contains a string s consisting of lowercase Latin characters (2 \\leq |s| \\leq 2 \\cdot 10^5).The sum of |s| over all test cases does not exceed 3 \\cdot 10^5.",
        "outputSpecification": "For each test case, output a single integer the number of nonempty strings t \\neq \"\\texttt{a}\" that satisfy all constraints.",
        "public_tests": [
            {
                "input": "\n8aaaaababacabacbaaabaaabitsetababbaaaabbbyearnineteeneightyfour",
                "output": "\n4\n4\n1\n16\n1\n2\n3\n1\n"
            }
        ],
        "note": "In the first test case, t can be \"\\texttt{aa}\", \"\\texttt{aaa}\", \"\\texttt{aaaa}\", or the full string.In the second test case, t can be \"\\texttt{b}\", \"\\texttt{bab}\", \"\\texttt{ba}\", or the full string.In the third test case, the only such t is the full string.",
        "tags": [
            "brute force",
            "hashing",
            "implementation",
            "math",
            "string suffix structures",
            "strings",
            "*2000"
        ]
    },
    "1984E": {
        "name": "E. Shuffle",
        "time_limit": {
            "value": 2,
            "unit": "seconds"
        },
        "mem_limit": {
            "value": 256,
            "unit": "megabytes"
        },
        "description": "Two hungry red pandas, Oscar and Lura, have a tree T with n nodes. They are willing to perform the following shuffle procedure on the whole tree T exactly once. With this shuffle procedure, they will create a new tree out of the nodes of the old tree.   Choose any node V from the original tree T. Create a new tree T_2, with V as the root.  Remove V from T, such that the original tree is split into one or more subtrees (or zero subtrees, if V is the only node in T).  Shuffle each subtree with the same procedure (again choosing any node as the root), then connect all shuffled subtrees' roots back to V to finish constructing T_2. After this, Oscar and Lura are left with a new tree T_2. They can only eat leaves and are very hungry, so please find the maximum number of leaves over all trees that can be created in exactly one shuffle.Note that leaves are all nodes with degree 1. Thus, the root may be considered as a leaf if it has only one child.",
        "inputSpecification": "The first line contains a single integer t (1 \\leq t \\leq 10^4) the number of test cases.The first line of every test case contains a single integer n (2 \\leq n \\leq 2 \\cdot 10^5) the number of nodes within the original tree T.The next n - 1 lines each contain two integers u and v (1 \\leq u, v \\leq n) an edge within the original tree T. The given edges form a tree.The sum of n over all test cases does not exceed 3 \\cdot 10^5.",
        "outputSpecification": "For each test case, output a single integer the maximum number of leaves achievable with exactly one shuffle procedure on the whole tree.",
        "public_tests": [
            {
                "input": "\n451 21 32 42 551 22 33 44 561 21 31 41 51 6109 38 110 68 57 84 61 310 12 7",
                "output": "\n4\n3\n5\n6\n"
            }
        ],
        "note": "In the first test case, it can be shown that the maximum number of leaves is 4. To accomplish this, we can start our shuffle with selecting node 3 as the new root.    Next, we are left only with one subtree, in which we can select node 2 to be the new root of that subtree.    This will force all 3 remaining nodes to be leaves, and once we connect them back to our new root, the shuffled subtree looks like this:    We connect the shuffled subtree back to our new root of our new tree. Our final tree has four leaves (including the root), and looks like this:   In our second test case, we have a line of five nodes. It can be shown that the maximum number of leaves after one shuffle is 3. We can start off with node 2, which forces node 1 to become a leaf. Then, if we select node 4 on the right side, we will also have nodes 3 and 5 as leaves.The third test case is a star graph with six nodes. The number of leaves cannot increase, thus our answer will be 5 (if we start the shuffling with the original root node).",
        "tags": [
            "dp",
            "greedy",
            "trees",
            "*2400"
        ]
    },
    "1984F": {
        "name": "F. Reconstruction",
        "time_limit": {
            "value": 2,
            "unit": "seconds"
        },
        "mem_limit": {
            "value": 256,
            "unit": "megabytes"
        },
        "description": "There is a hidden array a_1, a_2, \\ldots, a_n of length n whose elements are integers between -m and m, inclusive.You are given an array b_1, b_2, \\ldots, b_n of length n and a string s of length n consisting of the characters \\texttt{P}, \\texttt{S}, and \\texttt{?}.For each i from 1 to n inclusive, we must have:   If s_i = \\texttt{P}, b_i is the sum of a_1 through a_i.  If s_i = \\texttt{S}, b_i is the sum of a_i through a_n. Output the number of ways to replace all \\texttt{?} in s with either \\texttt{P} or \\texttt{S} such that there exists an array a_1, a_2, \\ldots, a_n with elements not exceeding m by absolute value satisfying the constraints given by the array b_1, b_2, \\ldots, b_n and the string s.Since the answer may be large, output it modulo 998\\,244\\,353.",
        "inputSpecification": "The first line contains a single integer t (1 \\leq t \\leq 10^3) the number of test cases.The first line of each test case contains two integers n and m (2 \\leq n \\leq 2 \\cdot 10^3, 2 \\leq m \\leq 10^{9}) the length of the hidden array a_1, a_2, \\ldots, a_n and the maximum absolute value of an element a_i.The second line of each test case contains a string s of length n consisting of characters \\texttt{P}, \\texttt{S}, and \\texttt{?}.The third line of each test case contains n integers b_1, b_2, \\ldots, b_n (|b_i| \\leq m \\cdot n).The sum of n over all test cases does not exceed 5 \\cdot 10^3.",
        "outputSpecification": "For each test case, output a single integer the number of ways to replace all \\texttt{?} in s with either \\texttt{P} or \\texttt{S} that result in the existence of a valid array a_1, a_2, \\ldots, a_n, modulo 998\\,244\\,353.",
        "public_tests": [
            {
                "input": "\n64 10PSPP1 9 8 104 1000000000????1 1 1 40000000008 1000000000?P?SSP?P-857095623 -1424391899 -851974476 673437144 471253851 -543483033 364945701 -1785373324 7PPSS4 2 1 39 20?????????1 2 3 4 5 6 7 8 93 1000000000P??-145463248 -974068460 -1287458396",
                "output": "\n1\n0\n2\n1\n14\n1\n"
            }
        ],
        "note": "In the first test case, we can see that the following array satisfies all constraints, thus the answer is 1:   \\texttt{P} {[\\color{red}{\\textbf{1}},3,4,2]}: sum of 1.  \\texttt{S} {[1,\\color{red}{\\textbf{3},4,2}]}: sum of 9.  \\texttt{P} {[\\color{red}{1,3,\\textbf{4}},2]}: sum of 8.  \\texttt{P} {[\\color{red}{1,3,4,\\textbf{2}}]}: sum of 10. In the second test case, it can be shown that no array a with all |a_i| \\leq m = 10^9 satisfies all constraints.",
        "tags": [
            "brute force",
            "dp",
            "math",
            "*2500"
        ]
    },
    "1985A": {
        "name": "A. Creating Words",
        "time_limit": {
            "value": 1,
            "unit": "second"
        },
        "mem_limit": {
            "value": 256,
            "unit": "megabytes"
        },
        "description": "Matthew is given two strings a and b, both of length 3. He thinks it's particularly funny to create two new words by swapping the first character of a with the first character of b. He wants you to output a and b after the swap.Note that the new words may not necessarily be different.",
        "inputSpecification": "The first line contains t (1 \\leq t \\leq 100)  the number of test cases.The first and only line of each test case contains two space-separated strings, a and b, both of length 3. The strings only contain lowercase Latin letters.",
        "outputSpecification": "For each test case, after the swap, output a and b, separated by a space.",
        "public_tests": [
            {
                "input": "\n6bit setcat doghot doguwu owocat catzzz zzz",
                "output": "\nsit bet\ndat cog\ndot hog\nowu uwo\ncat cat\nzzz zzz\n"
            }
        ],
        "note": null,
        "tags": [
            "implementation",
            "strings",
            "*800"
        ]
    },
    "1985B": {
        "name": "B. Maximum Multiple Sum",
        "time_limit": {
            "value": 1,
            "unit": "second"
        },
        "mem_limit": {
            "value": 256,
            "unit": "megabytes"
        },
        "description": "Given an integer n, find an integer x such that:   2 \\leq x \\leq n.  The sum of multiples of x that are less than or equal to n is maximized. Formally, x + 2x + 3x + \\dots + kx where kx \\leq n is maximized over all possible values of x. ",
        "inputSpecification": "The first line contains t (1 \\leq t \\leq 100) the number of test cases.Each test case contains a single integer n (2 \\leq n \\leq 100).",
        "outputSpecification": "For each test case, output an integer, the optimal value of x. It can be shown there is only one unique answer.",
        "public_tests": [
            {
                "input": "\n2315",
                "output": "\n3\n2\n"
            }
        ],
        "note": "For n = 3, the possible values of x are 2 and 3. The sum of all multiples of 2 less than or equal to n is just 2, and the sum of all multiples of 3 less than or equal to n is 3. Therefore, 3 is the optimal value of x.For n = 15, the optimal value of x is 2. The sum of all multiples of 2 less than or equal to n is 2 + 4 + 6 + 8 + 10 + 12 + 14 = 56, which can be proven to be the maximal over all other possible values of x.",
        "tags": [
            "brute force",
            "math",
            "number theory",
            "*800"
        ]
    },
    "1985C": {
        "name": "C. Good Prefixes",
        "time_limit": {
            "value": 2,
            "unit": "seconds"
        },
        "mem_limit": {
            "value": 256,
            "unit": "megabytes"
        },
        "description": "Alex thinks some array is good if there exists some element that can be represented as the sum of all other elements (the sum of all other elements is 0 if there are no other elements). For example, the array [1,6,3,2] is good since 1+3+2=6. Furthermore, the array [0] is also good. However, the arrays [1,2,3,4] and [1] are not good.Alex has an array a_1,a_2,\\ldots,a_n. Help him count the number of good non-empty prefixes of the array a. In other words, count the number of integers i (1 \\le i \\le n) such that the length i prefix (i.e. a_1,a_2,\\ldots,a_i) is good.",
        "inputSpecification": "The first line of the input contains a single integer t (1 \\leq t \\leq 10^4)  the number of test cases.The first line of each test case contains a single integer n (1 \\le n \\le 2 \\cdot 10^5)  the number of elements in the array.The second line of each test case contains n integers a_1,a_2,\\ldots,a_n (0 \\le a_i \\le 10^9)  the elements of the array.It is guaranteed that the sum of n over all test cases does not exceed 2 \\cdot 10^5. ",
        "outputSpecification": "For each test case, output a single integer  the number of good non-empty prefixes of the array a.",
        "public_tests": [
            {
                "input": "\n7101141 1 2 050 1 2 1 471 1 0 3 5 2 1271000000000 1000000000 1000000000 1000000000 1000000000 1000000000 294967296100 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 589934592",
                "output": "\n1\n0\n3\n3\n4\n1\n2\n"
            }
        ],
        "note": "In the fourth test case, the array has five prefixes:   prefix [0] is a good array, as mentioned in the statement;  prefix [0, 1] is not a good array, since 0 \\ne 1;  prefix [0, 1, 2] is not a good array, since 0 \\ne 1 + 2, 1 \\ne 0 + 2 and 2 \\ne 0 + 1;  prefix [0, 1, 2, 1] is a good array, since 2 = 0 + 1 + 1;  prefix [0, 1, 2, 1, 4] is a good array, since 4 = 0 + 1 + 2 + 1. As you can see, three of them are good, so the answer is 3.",
        "tags": [
            "greedy",
            "*1000"
        ]
    },
    "1985D": {
        "name": "D. Manhattan Circle",
        "time_limit": {
            "value": 2,
            "unit": "seconds"
        },
        "mem_limit": {
            "value": 256,
            "unit": "megabytes"
        },
        "description": "Given a n by m grid consisting of '.' and '#' characters, there exists a whole manhattan circle on the grid. The top left corner of the grid has coordinates (1,1), and the bottom right corner has coordinates (n, m).Point (a, b) belongs to the manhattan circle centered at (h, k) if |h - a| + |k - b| &lt; r, where r is a positive constant.On the grid, the set of points that are part of the manhattan circle is marked as '#'. Find the coordinates of the center of the circle.",
        "inputSpecification": "The first line contains t (1 \\leq t \\leq 1000)  the number of test cases.The first line of each test case contains n and m (1 \\leq n \\cdot m \\leq 2 \\cdot 10^5) the height and width of the grid, respectively. The next n lines contains m characters '.' or '#'. If the character is '#', then the point is part of the manhattan circle.It is guaranteed the sum of n \\cdot m over all test cases does not exceed 2 \\cdot 10^5, and there is a whole manhattan circle on the grid.",
        "outputSpecification": "For each test case, output the two integers, the coordinates of the center of the circle.",
        "public_tests": [
            {
                "input": "\n65 5............#............5 5..#...###.#####.###...#..5 6.............#....###....#....1 1#5 6...#....###..#####..###....#..2 10.............#......",
                "output": "\n3 3\n3 3\n4 2\n1 1\n3 4\n2 4\n"
            }
        ],
        "note": null,
        "tags": [
            "implementation",
            "math",
            "*900"
        ]
    },
    "1985E": {
        "name": "E. Secret Box",
        "time_limit": {
            "value": 1,
            "unit": "second"
        },
        "mem_limit": {
            "value": 256,
            "unit": "megabytes"
        },
        "description": "Ntarsis has a box B with side lengths x, y, and z. It lies in the 3D coordinate plane, extending from (0,0,0) to (x,y,z). Ntarsis has a secret box S. He wants to choose its dimensions such that all side lengths are positive integers, and the volume of S is k. He can place S somewhere within B such that:   S is parallel to all axes.  every corner of S lies on an integer coordinate. S is magical, so when placed at an integer location inside B, it will not fall to the ground. Among all possible ways to choose the dimensions of S, determine the maximum number of distinct locations he can choose to place his secret box S inside B. Ntarsis does not rotate S once its side lengths are selected.",
        "inputSpecification": "The first line consists of an integer t, the number of test cases (1 \\leq t \\leq 2000). The description of the test cases follows.The first and only line of each test case contains four integers x, y, z and k (1 \\leq x, y, z \\leq 2000, 1 \\leq k \\leq x \\cdot y \\cdot z).It is guaranteed the sum of all x, sum of all y, and sum of all z do not exceed 2000 over all test cases.Note that k may not fit in a standard 32-bit integer data type.",
        "outputSpecification": "For each test case, output the answer as an integer on a new line. If there is no way to select the dimensions of S so it fits in B, output 0.",
        "public_tests": [
            {
                "input": "\n73 3 3 83 3 3 185 1 1 12 2 2 73 4 2 124 3 1 61800 1800 1800 4913000000",
                "output": "\n8\n2\n5\n0\n4\n4\n1030301\n"
            }
        ],
        "note": "For the first test case, it is optimal to choose S with side lengths 2, 2, and 2, which has a volume of 2 \\cdot 2 \\cdot 2 = 8. It can be shown there are 8 ways to put S inside B.The coordinate with the least x, y, and z values for each possible arrangement of S are:   (0, 0, 0)  (1, 0, 0)  (0, 1, 0)  (0, 0, 1)  (1, 0, 1)  (1, 1, 0)  (0, 1, 1)  (1, 1, 1) The arrangement of S with a coordinate of (0, 0, 0) is depicted below:  For the second test case, S with side lengths 2, 3, and 3 are optimal.",
        "tags": [
            "brute force",
            "combinatorics",
            "math",
            "*1200"
        ]
    },
    "1985F": {
        "name": "F. Final Boss",
        "time_limit": {
            "value": 2,
            "unit": "seconds"
        },
        "mem_limit": {
            "value": 256,
            "unit": "megabytes"
        },
        "description": "You are facing the final boss in your favorite video game. The boss enemy has h health. Your character has n attacks. The i'th attack deals a_i damage to the boss but has a cooldown of c_i turns, meaning the next time you can use this attack is turn x + c_i if your current turn is x. Each turn, you can use all attacks that are not currently on cooldown, all at once. If all attacks are on cooldown, you do nothing for the turn and skip to the next turn.Initially, all attacks are not on cooldown. How many turns will you take to beat the boss? The boss is beaten when its health is 0 or less.",
        "inputSpecification": "The first line contains t (1 \\leq t \\leq 10^4)  the number of test cases.The first line of each test case contains two integers h and n (1 \\leq h, n \\leq 2 \\cdot 10^5) the health of the boss and the number of attacks you have.The following line of each test case contains n integers a_1, a_2, ..., a_n (1 \\leq a_i \\leq 2 \\cdot 10^5) the damage of your attacks.The following line of each test case contains n integers c_1, c_2, ..., c_n (1 \\leq c_i \\leq 2 \\cdot 10^5) the cooldown of your attacks.It is guaranteed that the sum of h and n over all test cases does not exceed 2 \\cdot 10^5.",
        "outputSpecification": "For each test case, output an integer, the minimum number of turns required to beat the boss.",
        "public_tests": [
            {
                "input": "\n83 22 12 15 22 12 150 35 6 75 6 750 32 2 23 3 390000 2200000 2000001 1100000 112000006 73 2 3 2 3 1 26 5 9 5 10 7 721 61 1 1 1 1 15 5 8 10 7 6",
                "output": "\n1\n3\n15\n25\n1\n19999800001\n1\n21\n"
            }
        ],
        "note": "For the first test case, you can use attacks 1 and 2 on the first turn, dealing 3 damage in total, and slaying the boss.For the second case, you can beat the boss in 3 turns by using the following attacks:Turn 1: Use attacks 1 and 2, dealing 3 damage to the boss. The boss now has 2 health left.Turn 2: Use attack 2, dealing 1 damage to the boss. The boss now has 1 health left.Turn 3: Use attack 1, dealing 2 damage to the boss. The boss now has -1 health left. Since its health is less than or equal to 0, you beat the boss.For the sixth test case: remember to use 64-bit integers as the answer can get large.",
        "tags": [
            "binary search",
            "data structures",
            "*1500"
        ]
    }
}